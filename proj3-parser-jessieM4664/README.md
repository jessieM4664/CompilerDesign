# Programming Assignment 3: Parser

-----

### Date Out: Tuesday, October 3
### Due Date: Tuesday, October 31 (start of class)

-----

## Introduction

This programming assignment extends our compiler's frontend to parsing!

In this assignment we will continue to use the popular [Java Compiler Compiler (JavaCC)](http://javacc.org/) parser tool.

**Do read this!** JavaCC is a *top-down, recursive-descent parser*, meaning that grammars must not have any left recursion, and "common prefixes" must be handled (either by left factoring, or via the `LOOKAHEAD` directive). Of course, the grammar should also not be ambiguous. Our RAM grammar that we will supply to JavaCC will, for the most part, be LL(1). However, it is possible to specify in the grammar a `LOOKAHEAD` directive to instruct JavaCC to peek at more than the next token in order to decide which production is appropriate to use next in a parse. Thus, the grammar can be LL(2), LL(3), ... LL(k) at specific points.

In a compiler, the input to a Parser is the token stream output from a Scanner. However, JavaCC is a tool that generates both a scanner and parser in one.

As you know, JavaCC takes a specification file (`.jj` extension), which contains both a lexical specification and a grammar, and automatically generates several Java files. One of these files, `RamParser.java`, defines the LL(k) recursive-descent parser with selective lookahead based on a grammar!

*(There are many other parser tools: Yacc and Bison are classical LALR parser generators for the C programming language; Bison is a modern extension to Yacc and is often used with lexical output from Flex. Both Yacc and Bison can also generate Java. CUP is a parser that is typically used to follow the JFlex scanner; however, it also is LALR, rather than LL. An LL parser that is gaining in popularity is ANTLR.)*

## The Tasks

### Setup

[This section is entirely identical to the _Setup_ in Programming Assignment #2 (the scanner).]

1. **Understand.** As always, think before you code. The IntelliJ project infrastructure in this assignment is the same as in Programming Assignment #2 (the scanner). Utilize our discord channel for questions and help.

2. **Ready to Start Coding?** Follow the same steps as in Programming Assignment #0 to "accept" the GHC assignment, and then clone your GH repo into your local IntelliJ.

3. **Start Coding and Use Maven** Initially, IntelliJ won't be happy with your starter code. But don't worry, everything will still work:

* `compilers.Ram23Compiler` (located in `src/main/java/compilers/Ram23Compiler.java`) may not be able to find `compilers.RamParser` (which will be generated and saved into `target/generated-sources/javacc/compilers/RamParser.java`) -- this is fine. This file is created automatically by JavaCC using our lexical specification.

We'll be interacting with our project solely through `Maven`, as demonstrated in class. You can either do this from the terminal, or via IntelliJ. The following is the general workflow of the project:

1. `mvn clean` -- will erase everything from the `target` directory in your project, including any generated `.class` files and `.java` source files generated by `JavaCC`
2. `mvn javacc:javacc` -- runs JavaCC against your lexical specification, automatically creating `.java` files that are placed in the `target/generated-sources/javacc/compilers/` directory. **Whenever you edit/modify the `.jj` file, you need to re-generate the scanner by executing this step.**
3. running the `compilers.Ram23Compiler` driver -- tests your scanner against a single `.ram23` program
4. `mvn test` -- runs your scanner against multiple test cases in batch

Notive that the `pom.xml` Maven configuration file now includes a JavaCC dependency (so JavaCC is automatically downloaded and 
included in your project), as well as a JavaCC Maven plugin (so that we can call a `javacc` goal from within Maven). You don't have to 
modify anything in this file. 

* The only file that you need to modify for this project is `src/main/javacc/RamGrammar.jj`
* **The only file that you need to modify for this project is `src/main/javacc/RamGrammar.jj`**
* <b><u>The only file that you need to modify for this project is `src/main/javacc/RamGrammar.jj`</u></b>

### JavaCC

Building off on the last assignment, continue to familiar yourself with JavaCC, and in particular, the _grammar_ aspects. Some additional resources:
* Our Thain textbook is generating a compiler for the C language, using C tools. In section 3.7, Thain talks about a scanner generator
named Flex. You'll notice that JavaCC works the same way as the original Flex tool.
<!--* The Appel text has a very dense, terse, intro on JavaCC. Start there.-->
* A more complete documentation/readme can be found here [Theodore Norvell's JavaCC FAQ](http://www.engr.mun.ca/~theo/JavaCC-FAQ/javacc-faq-moz.htm). Chapters 1-3, and especially Ch. 3, were the most relevant for the scanner. **For this parser assignment, you may wish to look at Chapters 4.1 - 4.7, 4.13, 4.20.**
* [JavaCC LOOKAHEAD MiniTutorial](https://javacc.org/tutorials/lookahead) ("syntactic lookahead" and "semantic lookahead" will not be necessary for this assignment)
* Other links that I found useful: [1 ](http://www.engr.mun.ca/~theo/JavaCC-Tutorial/javacc-tutorial.pdf)[2](http://cs.lmu.edu/~ray/notes/javacc/)
* Note that there are many advanced parsing features built into JavaCC. You don't need to know *everything* about Javacc to complete the assignment; it is possible to write the grammar for this assignment using only JavaCC's basic constructs. **In short, do not use anything in this assignment that you don't understand. Copying complex grammars that you do not understand is considered cheating!**

### Ram23 Resources

Links to the MiniJava and Ram23 Specification are in the starter code repo.

### Specifying the grammar for our Ram23 Programming Language

Code the complete grammar for Ram23 in `src/main/javacc/RamGrammar.jj`. Because JavaCC is a recursive-descent parser, left-recursion must be removed from the grammar. (JavaCC will output a warning if it detects left recursion.) Notice that some of the *Exp* production rules in Ram23 are left recursive.

Because JavaCC can perform `LOOKAHEAD` when specified (see the above JavaCC resources), this sometimes avoids the necessity to left-factor the grammar. (The downside to lookahead is performance cost, depending on how much lookahead is used; the upside is that the grammar can retain some of its simplicity by avoiding another rewriting step.)

In general,

1. create a production for each non-terminal in the grammar
2. follow the grammar and utilize the token classes that I already defined in the lexical specification portion of `RamToken()` in `RamGrammar.jj`
3. eliminate left recursion (by rewriting and introducing new non-terminals)
4. is there any need to left factor?
5. include appropriate `LOOKAHEAD(k)` instructions
6. debug!

To get you started, here are my first few productions. Notice: for the Scanner (Programming Assignment #2), a successful tokenization involved performing the `Goal()` production, which derived to zero or more `RamToken()`'s; for this Parsing assignment, a stream of tokens which is grammatically correct involves calling the `Goal()` production (which is not commented out), which calls `Program()`, which calls `MainClass()` and `ClassDecl()`, which ... you complete the rest ...

Notice that the below productions correspond exactly with the Ram23 grammar. `ClassDecl()`, and `Statement()` are other nonterminals whose productions rules will have to be defined by you.

```
void Goal() :
{}
{  
  /* ( RamToken() )*  <EOF> */
  Program() <EOF> 
}

void RamToken():
{}
{
  <CLASS>  |  <IDENTIFIER> | <LBRACE> | <PUBLIC> | <STATIC> | <VOID> |
  <MAIN> | <LPAREN> | <STRING> | <LSQPAREN> | <RSQPAREN> | <RPAREN> | <RBRACE> |
  <PLUSEQUALS> | <MINUSEQUALS> | <SEMICOLON> | <RETURN> | <COMMA> | <INTEGER> | <BOOLEAN> | <ASSIGN> |
  <IF> | <ELSE> | <WHILE> | <COLON> | <PRINT> | <PRINTLN> | <AND> |
  <OR> | <LESSTHAN> | <EQUALITY> | <PLUS> | <MINUS> | <TIMES> |
  <DOT> | <LENGTH> | <INTEGER_LITERAL> | <TRUE> | <FALSE> | <THIS> | <NEW> |
  <EXCLAMATION>
}

void Program() :
{}
{
    MainClass() ( ClassDecl() )*
}

void MainClass() :
{}
{
    <CLASS> <IDENTIFIER> <LBRACE> <PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN> 
    <STRING> <LSQPAREN> <RSQPAREN> <IDENTIFIER> <RPAREN> <LBRACE> 
    Statement() 
    <RBRACE> <RBRACE>
}
```

Also add to your grammar any necessary additions to the MiniJava language as defined in our Ram23 specification.

Run JavaCC on your specification file, by runnning the `mvn javacc:javacc` Maven plugin goal. Notice the created Java files in the `target/generated-sources/javacc/compilers/` directory. This is the same idea as what we did for the Scanner.

- *Other notes to help you understand `RamGrammar.jj`*: The start production in the starter code grammar is `Goal --> Program $`. (If you want to make JavaCC function only as a Scanner, simply switch the line that is commented out from line 100 to line 101. Line 100 says that a valid program is any that contains zero or more RamTokens; the only way this grammar wouldn't successfully parse an input program would be if that program contains some token that it wasn't expecting.)

Follow the same approach as in Programming Assignment #2 to test your parser on either a single file, or multiple files. (Consult with the visual slides that I presented when Programming Assignment #2 was released.)

* Run the Parser on a single file: examine and run the `compilers.Ram23Compiler` driver.
* Run the Parser on multiple files: create a good sample of Ram programs and run your generated Parser on them using the `test` Maven lifecycle. Is the output of the Lexer what you expected?

## Project Structure

Ram23Compiler:

* `pom.xml` (Maven configuration file)
* `src/main/java/compilers/Ram23Compiler.java` (driver file to test a single .ram23 source file)
* `src/main/javacc/RamGrammar.jj` (grammar specification for Ram23)
* `src/test/java/compilers/test_programs/pass/`(Ram programs with no syntactical errors)
* `src/test/java/compilers/test_programs/fail/`(Ram programs that have syntactical errors)
* `src/test/java/compilers/test_programs/PassTest.java` (a junit class for running ram23 programs that should pass the parser)   
* `target/generated-sources/javacc/compilers/` (directory to hold the automatically generated files)
* `target/classes/` (compiled files)


## CSC416 vs CSC565

Additional work for **CSC565 students only**:

1. Add three pass tests (`.ram23` files) and three fail tests to the `test_programs` folder. You'll also need to modify the `PassTest.java` and `FailTest.java` test suites.
1. Also add a `for` loop into the language, where updates must utilize either `+=` or `-=`.

## Submission instructions

Push your completed Java Maven project to your GitHub. Verify the success of the autograding GitHub Action.